// +build ignore

package main

// This program generates palette.go. Invoke it as
//	go run genpalettes.go -output palette.go

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"image"
	"image/color"
	"image/png"
	"io/ioutil"
	"math"
	"net/http"
	"os"
	"regexp"
	"strings"

	"github.com/gocolly/colly/v2"
	"github.com/sgreben/piecewiselinear"
)

type paletteGradient struct {
	Start, End float64
	SC, EC     color.RGBA
}

var palettes = make(map[string][]color.RGBA)
var filename = "palette.go"
var sizex = 256

func parsePalette(imgurl, imgname string) error {
	paletteurl := imgurl[0:len(imgurl)-3] + "cpt"
	paletteurl = strings.ReplaceAll(paletteurl, "tn/", "")
	// fmt.Println(paletteurl)

	//Get the response bytes from the url
	client := &http.Client{}
	req, err := http.NewRequest("GET", paletteurl, nil)

	// without referrer header we get a 403
	req.Header.Add("Referer", imgurl+`.index.html`)

	response, err := client.Do(req)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	// fmt.Println(response.StatusCode)

	if response.StatusCode != 200 {
		return errors.New("Received non 200 response code")
	}

	var data []byte
	data, err = ioutil.ReadAll(response.Body)
	if err != nil {
		return err
	}

	reg, err := regexp.Compile(`^ +.*$`)

	var starti, endi float64
	var s, e color.RGBA
	var matchCount int

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		if reg.MatchString(line) {
			matchCount++
		}
	}

	gradients := make([]paletteGradient, matchCount)
	matchCount = 0
	for _, line := range lines {
		if reg.MatchString(line) {
			s.A = 255
			e.A = 255
			fmt.Sscanf(line, "%f %d %d %d %f %d %d %d", &starti, &s.R, &s.G, &s.B, &endi, &e.R, &e.G, &e.B)
			// fmt.Println(starti, s, endi, e)
			gradients[matchCount].Start = starti
			gradients[matchCount].End = endi
			gradients[matchCount].SC = s
			gradients[matchCount].EC = e
			matchCount++
		}
	}

	palette := genPalette(gradients)

	// savePaletteAsPNG(palette, imgname)

	// fmt.Printf("%v\n", palette)
	fmt.Println(imgname[0 : len(imgname)-4])
	palettes[imgname[0:len(imgname)-4]] = palette

	return nil

}

func genPalette(gradients []paletteGradient) []color.RGBA {

	xs := make([]float64, sizex)
	for i := range xs {
		xs[i] = float64(i) / float64(sizex-1)
	}

	gradientX := make([]float64, len(gradients)+1)
	for i, gradient := range gradients {
		gradientX[i] = gradient.Start / 100
	}
	gradientX[len(gradients)] = 1.0

	gradientYR := make([]float64, len(gradients)+1)
	for i, gradient := range gradients {
		gradientYR[i] = float64(gradient.SC.R)
	}
	gradientYR[len(gradients)] = float64(gradients[len(gradients)-1].EC.R)

	gradientYG := make([]float64, len(gradients)+1)
	for i, gradient := range gradients {
		gradientYG[i] = float64(gradient.SC.G)
	}
	gradientYG[len(gradients)] = float64(gradients[len(gradients)-1].EC.G)

	gradientYB := make([]float64, len(gradients)+1)
	for i, gradient := range gradients {
		gradientYB[i] = float64(gradient.SC.B)
	}
	gradientYB[len(gradients)] = float64(gradients[len(gradients)-1].EC.B)

	fR := piecewiselinear.Function{Y: gradientYR, X: gradientX}
	fG := piecewiselinear.Function{Y: gradientYG, X: gradientX}
	fB := piecewiselinear.Function{Y: gradientYB, X: gradientX}

	palette := make([]color.RGBA, sizex)
	for i := range palette {
		x := float64(i) / float64(sizex-1)
		palette[i] = color.RGBA{uint8(math.Round(fR.At(x))), uint8(math.Round(fG.At(x))), uint8(math.Round(fB.At(x))), 255}
	}

	return palette
}

func savePaletteAsPNG(palette []color.RGBA, imgname string) error {
	sizey := 16
	sizex := len(palette)
	img := image.NewRGBA(image.Rectangle{image.Point{0, 0}, image.Point{sizex, sizey}})

	for x := 0; x < sizex; x++ {
		for y := 0; y < sizey; y++ {
			img.Set(x, y, palette[x])
		}
	}

	//Create a empty file
	file, err := os.Create(imgname)
	if err != nil {
		return err
	}
	defer file.Close()

	err = png.Encode(file, img)
	if err != nil {
		return err
	}

	return nil
}

func exportToGo() error {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by go run genpalettes.go -output palette.go; DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package palette")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, `import "image/color"`)
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, `// This is a list of palettes from http://soliton.vm.bytemark.co.uk/pub/cpt-city/rc/ as a single lookup variable`)
	fmt.Fprintln(&buf, `// its a two dimensional variable with the first parameter being different palettes and the second`)
	fmt.Fprintln(&buf, `// is the 256 length table of the palette colors`)
	fmt.Fprintln(&buf, `var Palettes = [][]color.RGBA{`)

	// first the default palette
	for key, element := range palettes {
		if key == "default" {
			fmt.Fprintf(&buf, "{ // %s\n", key)
			for _, c := range element {
				fmt.Fprintf(&buf, "\tcolor.RGBA{0x%02x, 0x%02x, 0x%02x, 0xff},\n", c.R, c.G, c.B)
			}
			fmt.Fprintln(&buf, `},`)
			break
		}
	}

	// then the rest
	for key, element := range palettes {
		if key != "default" {
			fmt.Fprintf(&buf, "{ // %s\n", key)
			for _, c := range element {
				fmt.Fprintf(&buf, "\tcolor.RGBA{0x%02x, 0x%02x, 0x%02x, 0xff},\n", c.R, c.G, c.B)
			}
			fmt.Fprintln(&buf, `},`)
		}
	}
	fmt.Fprintln(&buf, `}`)
	fmt.Fprintln(&buf)

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return err
	}

	return nil
}

func main() {
	// Instantiate default collector
	c := colly.NewCollector()

	re, _ := regexp.Compile("^.*\\.png\\.")

	baseurl := "http://soliton.vm.bytemark.co.uk/pub/cpt-city/rc/"

	// On every a element which has href attribute call callback
	c.OnHTML("a[href]", func(e *colly.HTMLElement) {
		link := e.Attr("href")
		// Print link
		if re.MatchString(link) {
			// fmt.Printf("Link found: %s\n", link)
			imgurl := baseurl + strings.ReplaceAll(link, ".index.html", "")
			// fmt.Printf("Image found: %s\n", imgurl)

			imgname := strings.ReplaceAll(link, ".index.html", "")
			imgname = strings.ReplaceAll(imgname, "tn/", "")

			err := parsePalette(imgurl, imgname)
			if err != nil {
				fmt.Println(err)
			}
		}
		// Visit link found on page
		// Only those links are visited which are in AllowedDomains
		// c.Visit(e.Request.AbsoluteURL(link))
	})

	// Before making a request print "Visiting ..."
	c.OnRequest(func(r *colly.Request) {
		// fmt.Println("Visiting", r.URL.String())
	})

	// Start scraping on https://hackerspaces.org
	c.Visit(baseurl + "index.html")

	fmt.Printf("done\n")

	//adding default green yellow red pallete

	defaultGradient := []paletteGradient{
		{
			0, 50, color.RGBA{0, 255, 0, 255}, color.RGBA{255, 255, 0, 255},
		},
		{
			50, 100, color.RGBA{255, 255, 0, 255}, color.RGBA{255, 0, 0, 255},
		},
	}
	palettes["default"] = genPalette(defaultGradient)

	err := exportToGo()
	if err != nil {
		fmt.Println(err)
	}
}
